<!doctype html>
<html>
<head>
<title>Otus Programming Language</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="utf-8"/>
<meta name="description" content="Documentation and useful information about the Otus systems programming language. The Otus language aims to be low level and "simple but powerful""/>
<meta name="author" content="Simon DoksrÃ¸d"/><meta name="robots" content="index,follow"><link rel="stylesheet" type="text/css" href="style.css" title="main">
<script src="generated_script.js"></script>
</head>

<body>
<div id="page_container">
<div id="header">
<img src="Otus.svg" id="logo"/>
<ul id="navbar">
<li><a href="#about"><b>About</b></a></li><li class="navbar_vl">|</li>
<li><a href="#docs"><b>Docs</b></a></li><li class="navbar_vl">|</li>
<li><a href="#log"><b>Dev Log</b></a></li><li class="navbar_vl">|</li>
<li><a href="https://github.com/Soimn/Gremlin"><b>GitHub</b></a></li>
</ul>
</div>

<div id="content">

<div id="about_tab">
<h1>The Otus programming language</h1> The Otus programming language aims to be a <i>"simple but powerful"</i> alternative to C, and takes heavy inspiration from languages such as <a href="https://odin-lang.org/">Odin</a> and <a href="https://www.youtube.com/playlist?list=PLmV5I2fxaiCKfxMBrNsU1kgKJXD3PkyxO">Jai</a>. The current goal of the language is to be: <ul> <li><b>Clear and concise</b>, to remove unnecessary complexity</li> <li><b>Powerful</b>, to ease the development of large and complex software</li> <li><b>Lightweight</b>, to allow greater expressiveness without a loss of performance</li> </ul> </div>

<div id="docs_tab">
</div>

<div id="log_tab">
<div class="log_title_minimized id200617" onclick="window.location.hash='#log@id200617'"><a href="#log@id200617">Import declarations</a></div><div class="log_date_minimized id200617">2020/06/17</div>
<div class="log_content_minimized id200617">
Header files and dealing with cyclic imports has never really bothered me (except when I first learned C++ without knowing why header files existed in the first place). I was therefore quite puzzled when Jonathan Blow presented header files, along with C++'s arrow operator, as major issues with C++ in his video <a href="https://youtu.be/TH9VCN6UkyQ">about a better programming language for games</a>. At that time, I saw the benefit of removing header files, but also, in my opinion, a huge drawback. Include directives in C declare a dependency, but also serve as a guide as where to look for the implementation of anything in a given file. The implementation could of course be hidden behind N nested imports (N being a significantly large number), but you at least know that for any given identifier, that is not part of the C language, you will always find the implementation further up the file, or in one of the imported header files. This promise is important for understanding foreign code and is broken by the use of multiple compilation units (non-unity build), and the removal of the requirement for every file to import it's dependencies. Now, I'm not saying there is a problem with Jai because it does not have any header files (as it seems to only remove the forward declarations, not import dependencies), but it got me thinking. <br> <br> Import declarations should, in my opinion, declare a dependency on a file and allow access to all global declarations of that file in the current file's global scope. There is however a problem with this. If the import declaration imports everything in the target file, it will inevitably be impossible to hide the implementation of something behind anything larger than a procedure, or struct. This is a problem, since a lot things in programming benefit from "helper functions" that should only be visible to the to the intended users. Helper functions that are globally visible could lead to bugs due to use outside the intended scope of the function, and in the <a href="http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html">words of John Carmack</a>: <i>"Most bugs are a result of the execution state not being exactly what you think it is"</i>. Importing files should therefore be somewhat selective. Jai solves this by adding the concept of a file- and export scope. Every declaration in a file is local to that file (in file scope), unless it is exported. This seemed like a good idea, along with the use of compiler directives to indicate whether a block of code is exported or not. The only issue I have with Jai's import behaviour is that an import declaration seems to affect other imported files as well (similar to how textual imports sometimes break the "dependency promise" of each imported file). A problem with enforcing this "dependency promise" is that it adds a lot of redundant import declarations to common files and unnecessary visual clutter. However this could be solved by allowing the programmer to specify a group of files that should be implicitly imported in all source files. <br> <br> Then there is the question of how to deal with libraries. Ginger Bill's <a href="https://odin-lang.org/">Odin</a> has in this case been an example of how I personally think libraries should not be handled. This might be due to the fact that I don't use libraries since I despise having code in my codebase that I have not written, or fully understood myself. However, I think the way Odin requires every file to specify a parent package is damaging to the project. This is due to two issues I have with the approach: <ul> <li>being <u>mandatory</u> in every file, it introduces additional unnecessary visual clutter</li> <li>it might encourage enforcing stricter barriers, than optimal, between functionality in a codebase</li> </ul> The first issue is a trivial one, but the second is, in my opinion, a great flaw with the language. Now, I'm not saying code should be an entangled spaghetti mess, but I am definitely advocating that overly modularizing code is akin to trying to build a fortress from breadcrumbs. It is not necessarily bad to separate part of a code base in different files, or even libraries, but it is truly damaging to the code base when those barriers become a part of the high level description and mental image. Packages in Odin seem to only be used in distribution and import of several files as one. Allowing the programmer to import both files and directories, would in my opinion achieve a similar result, without the need for the concept of a package. Odin does however do a few things I like, namely "library collections", and import namespacing. In Odin you are able to prefix an import path with a label which declares which "library collection" that file is a part of. Adapting this to work with the file system instead could yield a sort of prefix path label, where the label is a sort of "shorthand" for an absolute path. This is useful since it explicitly declares where the compiler should look for a file without needing to specify the full path, instead of using a list of search paths in C. Import namespacing is also a step in the more explicit direction, as giving each imported declaration a mandatory prefix could both fix name collisions and increase readability. <br> <br> Import declarations in Otus will therefore be able to import single files or every source file in a directory. A prefix "name:" label could be added to change the search path from relative to absolute, with the path bound to the label being prepended to the import path. An alias, or namespace, can also be specified, which hides the imported declarations behind a "alias." barrier. Every file needs to import what it uses, except for what is chosen to be globally imported. </div>
<div class="log_title_minimized maed200614" onclick="window.location.hash='#log@maed200614'"><a href="#log@maed200614">Motivation and Early Development</a></div><div class="log_date_minimized maed200614">2020/06/14</div>
<div class="log_content_minimized maed200614">
Hi. I am Simon. A sometimes humble game and engine developer living in Norway, who apparently decided to stack mountains on top of each other to reach Mt. Olympus. The mountains being code and Olympus being an actual working compiler. Before recapping half a year of development, a bit of background. <br> <br> Around Christmas time last year, I grew a bit frustrated with C and C++. At the time I was working on my Nth iteration of a game engine, using a small subset of C++, and wanted to rewrite my MIN/MAX macros as proper functions to allow for type checking. Little did I know that the frustration of there being <u>no</u> implementation of MIN/MAX in C or C++ that I would be satisfied with. I tried out different versions of templated functions, which I despised, and eventually went on to scour for compiler specific C extensions. While searching I continuously chanted that "there must surely be a proper way to implement MIN/MAX functions in C". Eventually I stumbled upon "generic selection macros" in C. Compile time selection of expressions based on type seemed to be the solution I was looking for. However, there was still a slight problem with the approach. Apparently MSVC does not properly support any new (new being post 90's) features of the C language, making generic selection a no go. <br> <br> What I wanted from C, or C++, was the ability to write, or generate, a maximum of <u>three</u> functions (int, uint, float) and have the result cast to the correct common type. Now, this may seem like a negligible problem. Surely generating a small number of functions, or even using a C like naming scheme, would not harm the resulting program significantly. It was not this small scale issue I was troubled with, but rather the fact that the language prevented me from expressing what I wanted to do, without a lot of cruft. All the problems I had with C and C++, most of them being with C++, accumulated to critical mass right around the time I started watching <a href="https://www.youtube.com/playlist?list=PLmV5I2fxaiCKfxMBrNsU1kgKJXD3PkyxO">Jonathan Blow's</a> videos on his new language Jai. Jai seemed like a godsend at the time. I fondly remember working on the rendering API for my game engine while watching one of his compiler streams. When working on the rendering API I found myself wanting a way of "unpacking" structs. This would allow for standardizing common elements in structs, without needing to access the members via an intermediary variable. I was about to suggest this "struct unpacking" idea, when I realised that a superior version was already implemented in Jai (the using statement). It seemed however that Jai would release way off in the future, and I could not wait that long, so I decided to make my own language. <br> <br> The language started as an extension to C with added metaprogramming and altered casting rules. The syntax was similar to C, with some added quirks due to type inference, multiple return values and improved templates, and functioned almost exactly like C. This introduced some problems, as I had at that time never written a parser (or any other part of a compiler), and the many quirks of C syntax, including my own additions, seemed like too much. I therefore decided to alter the syntax a bit, changing it to look more like Jai. Along the way I also came up with some (I would say "interesting") ideas, and the syntax ended up being a hot mess. After several renditions due to aesthetics, holisticity and semantics, I arrived at a syntax similar to Jai, but different in a few subtle ways. <br> <br> I planned on using this language up until Jai released and then switch, but as the project grew I felt like I had arrived at a crossroads. One option would be to make a throwaway language and continue on engine development, another would be to pause the development of my existing projects and develop a proper language. This dilemma lead to a lot of frustration and hopelessness as I did not see myself being able to finish both the engine and the language in any reasonable time frame. However I did not like the idea of making a compiler for a throwaway language either. After working on a parser for the language I also found myself a bit repelled by the complexity of it. By extension I also found myself displeased with the complexity of Jai, as my language was supposed to be a simpler version of it (so that I could manage the development of it). At the same time I was watching a lot of language design talks, and stumbled upon <a href="https://odin-lang.org/">Odin</a>. Odin seemed to have taken a similar route to my language, simplifying Jai. However, I still found Odin to be a little too complex, and after developing the parser in C, I found that I really did not need much to program effectively. I therefore decided to throw everything I did not deem as necessary out the window, and strive to make the language as simple as possible. However simplifying the language too much could, strangely enough, lead to more complexity, as evident with machine language. I therefore adjusted my aim towards "simple but powerful", by reducing the moving parts of the language to a few powerful constructs that could be used directly or to build new abstractions. <br> <br> Lately I have been redesigning the language's syntax and semantics, as I found that a lot of the "unique" concepts I had introduced were not useful enough to outweigh the added complexity. One of those concepts was "infix function calling". This was a purely syntactical alternative to calling functions, allowing for operator-like functions with no semantic difference from a regular call. 
<div class="code">
// Normal function call
Inner(a, b);

// Infix call
a 'Inner' b;

// Prefix call
Length' a;

// Postfix call
a 'Length;
</div>
 This seemed like a good idea, since the language does not have operator overloading. It proved however to only be useful in very specific circumstances (like vector operations), that could often be solved by a more useful construct. I have also been sketching out the specifics of metaprogramming in the language, and have learned, by a lot of trial and error, that an integral feature of the language, such as metaprogramming, should <u>not</u> be retrofitted to an existing language, but rather built in tandem with it. <br> <br> And that is most of the early development of this language summarized, with most of the frustration, cuss words, stupidity and details removed for ease of reading. The language is still far from finished, especially since I decided to scrap months of work, but it seems like this project is feasible, and would possibly prove to be useful to at least one person. </div>
</div>
</div>
</div>
</body>
</html>